#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <cmath>
#include <thread>
#include <cstdio>    // popen, pclose
#include <algorithm> // std::min
#include <deque>     // para trails de COP
#include <mutex>
#include <sys/stat.h>
#define MKDIR(path) mkdir(path, 0777)

#include <opencv2/opencv.hpp>
#include <rapidjson/document.h>
#include <hiredis/hiredis.h>
#include <curl/curl.h>
#include <libpq-fe.h>

using namespace std;
using namespace cv;
using namespace rapidjson;

// Par谩metros de v铆deo y malla
constexpr int wFinal = 175;
constexpr int hFinal = 520;
constexpr int gridW = 20;
constexpr int gridH = 69;
constexpr double radius = 70.0;
constexpr double smoothness = 2.0;
constexpr double fps = 32.0;
constexpr int numThreads = 4;
constexpr int legendWidth = 80;
const string baseUrl = "http://ssith-backend-container:3000/swData/generateCSV/";
const string redisQueue = "redis_queue";

// PostgreSQL
PGconn *cnn = NULL;
PGresult *result = NULL;
const char *host = "sqlDB";
const char *port = "5432";
const char *dataBase = "ssith-db";
const char *user = "admin";
const char *passwd = "admin";

// API login (JWT)
const string apiUser = "marcos";
const string apiPassword = "zodv38jN0Bty5ns1";
const string loginUrl = "http://ssith-backend-container:3000/authentication/serviceLogin/";

// Callback para almacenar la respuesta del servidor
size_t WriteCallback(void *contents, size_t size, size_t nmemb, string *output)
{
    size_t total_size = size * nmemb;
    output->append((char *)contents, total_size);
    return total_size;
}

// Login y obtenci贸n de token JWT
string loginToAPI()
{
    CURL *curl;
    CURLcode res;
    string response;

    curl_global_init(CURL_GLOBAL_ALL);
    curl = curl_easy_init();
    if (curl)
    {
        string jsonData = "{\"user\":\"" + apiUser + "\",\"password\":\"" + apiPassword + "\"}";
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, loginUrl.c_str());
        curl_easy_setopt(curl, CURLOPT_POST, 1L);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonData.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

        res = curl_easy_perform(curl);
        if (res != CURLE_OK)
        {
            cerr << "Error en la solicitud: " << curl_easy_strerror(res) << endl;
        }
        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }
    curl_global_cleanup();
    return response;
}

// Token est谩tico con posible renovaci贸n futura
string &getToken()
{
    static string token;
    if (token.empty())
    {
        token = loginToAPI();
    }
    return token;
}

//------------------------------------------------------------
// 1) Leer coordenadas (JSON)
//------------------------------------------------------------
void read_coordinates(const string &filename, vector<pair<double, double>> &coordinates)
{
    ifstream file(filename);
    if (!file.is_open())
    {
        cerr << "No se pudo abrir " << filename << endl;
        return;
    }
    stringstream buffer;
    buffer << file.rdbuf();
    string json_str = buffer.str();

    Document doc;
    doc.Parse(json_str.c_str());
    if (doc.HasParseError() || !doc.IsArray())
    {
        cerr << "Error parseando " << filename << " o no es un array." << endl;
        return;
    }

    for (SizeType i = 0; i < doc.Size(); i++)
    {
        if (doc[i].HasMember("x") && doc[i].HasMember("y") &&
            doc[i]["x"].IsDouble() && doc[i]["y"].IsDouble())
        {
            double x = doc[i]["x"].GetDouble();
            double y = doc[i]["y"].GetDouble();
            coordinates.emplace_back(x, y);
        }
    }
}

//------------------------------------------------------------
// 2) Leer CSV: filas = frames, columnas = sensores
//------------------------------------------------------------
vector<vector<double>> read_csv(const string &filename)
{
    vector<vector<double>> data;
    ifstream file(filename);
    if (!file.is_open())
    {
        cerr << "No se pudo abrir " << filename << endl;
        return data;
    }
    string line;
    while (getline(file, line))
    {
        vector<double> row;
        stringstream ss(line);
        string val;
        while (getline(ss, val, ','))
        {
            try
            {
                row.push_back(stod(val));
            }
            catch (...)
            {
                row.push_back(0.0);
            }
        }
        data.push_back(row);
    }
    return data;
}

//------------------------------------------------------------
// 3) Generaci贸n de heatmap + colormap JET
//------------------------------------------------------------
Mat generate_heatmap_jet(
    const vector<pair<double, double>> &coords,
    const vector<int> &pressures,
    int widthFinal,
    int heightFinal,
    int gridW,
    int gridH,
    double radius,
    double smoothness)
{
    // A) Construir Z (gridH x gridW)
    vector<vector<double>> Z(gridH, vector<double>(gridW, 0.0));
    for (size_t i = 0; i < coords.size(); i++)
    {
        double x0 = coords[i].first;
        double y0 = coords[i].second;
        double p0 = pressures[i];
        for (int gy = 0; gy < gridH; gy++)
        {
            double Yg = (gy + 0.5) / double(gridH) * heightFinal;
            for (int gx = 0; gx < gridW; gx++)
            {
                double Xg = (gx + 0.5) / double(gridW) * widthFinal;
                double dx = Xg - x0;
                double dy = Yg - y0;
                double dist2 = dx * dx + dy * dy;
                double val = p0 * exp(-smoothness * (dist2 / (radius * radius)));
                Z[gy][gx] += val;
            }
        }
    }
    // B) Clampear a [0,4095]
    for (int gy = 0; gy < gridH; gy++)
    {
        for (int gx = 0; gx < gridW; gx++)
        {
            Z[gy][gx] = std::min(std::max(Z[gy][gx], 0.0), 4095.0);
        }
    }
    // C) Crear Mat CV_8UC1 (heightFinal x widthFinal)
    Mat grayImg(heightFinal, widthFinal, CV_8UC1);
    for (int y = 0; y < heightFinal; y++)
    {
        int gy = int((double)y / heightFinal * gridH);
        if (gy >= gridH)
            gy = gridH - 1;
        uchar *rowPtr = grayImg.ptr<uchar>(y);
        for (int x = 0; x < widthFinal; x++)
        {
            int gx = int((double)x / widthFinal * gridW);
            if (gx >= gridW)
                gx = gridW - 1;
            double v = Z[gy][gx];
            int scaled = int(v * (255.0 / 4095.0));
            scaled = std::min(std::max(scaled, 0), 255);
            rowPtr[x] = (uchar)scaled;
        }
    }
    // D) Aplicar colormap JET
    Mat colorImg;
    applyColorMap(grayImg, colorImg, COLORMAP_JET);
    return colorImg;
}

//------------------------------------------------------------
// 4) Dibujar puntos + 铆ndices
//------------------------------------------------------------
void draw_points_indices(Mat &img, const vector<pair<double, double>> &coords)
{
    Scalar circleColor(0, 0, 0);
    Scalar textColor(255, 255, 255);
    for (size_t i = 0; i < coords.size(); i++)
    {
        Point pt((int)coords[i].first, (int)coords[i].second);
        circle(img, pt, 5, circleColor, -1);
        Point txtPos = pt + Point(5, -5);
        putText(img, to_string(i), txtPos, FONT_HERSHEY_SIMPLEX, 0.4, textColor, 1, LINE_AA);
    }
}

//------------------------------------------------------------
// 5) Crear barra de colores JET
//------------------------------------------------------------
Mat create_jet_colorbar(int barWidth, int barHeight)
{
    Mat grayGrad(barHeight, barWidth, CV_8UC1);
    for (int y = 0; y < barHeight; y++)
    {
        double alpha = double(y) / (barHeight - 1);
        int val = int(255.0 * (1.0 - alpha));
        for (int x = 0; x < barWidth; x++)
        {
            grayGrad.at<uchar>(y, x) = (uchar)val;
        }
    }
    Mat colorBar;
    applyColorMap(grayGrad, colorBar, COLORMAP_JET);
    return colorBar;
}

//------------------------------------------------------------
// 6) Anotar ticks en la barra
//------------------------------------------------------------
void annotate_colorbar(Mat &colorBar, int barOffsetX, const vector<int> &ticks)
{
    int BH = colorBar.rows;
    int BW = colorBar.cols;
    for (int val : ticks)
    {
        double ratio = double(val) / 4095.0;
        int posY = BH - 1 - int(ratio * (BH - 1));
        line(colorBar, Point(BW - 2, posY), Point(BW, posY), Scalar(0, 0, 0), 1);
        putText(colorBar, to_string(val), Point(BW + 5, posY + 4),
                FONT_HERSHEY_SIMPLEX, 0.4, Scalar(0, 0, 0), 1, LINE_AA);
    }
}

//------------------------------------------------------------
// 7) Generar animaci贸n combinada de heatmap
//------------------------------------------------------------
void generate_combined_animation_JET(
    const vector<vector<int>> &pressures_left,
    const vector<vector<int>> &pressures_right,
    const vector<pair<double, double>> &coords_left,
    const vector<pair<double, double>> &coords_right,
    const string &outFilename)
{
    int margin = 50;
    int finalWidth = (wFinal * 2) + legendWidth + (margin * 3);
    int finalHeight = hFinal + (margin * 2);

    // Barra de colores
    int barWidth = 20;
    int barHeight = hFinal - 20;
    Mat colorBar = create_jet_colorbar(barWidth, barHeight);
    Mat legendContainer(barHeight, legendWidth, CV_8UC3, Scalar(255, 255, 255));
    Rect roiBar(10, 0, barWidth, barHeight);
    colorBar.copyTo(legendContainer(roiBar));
    vector<int> tickVals = {0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000};
    annotate_colorbar(legendContainer, 10 + barWidth, tickVals);

    // FFmpeg pipe
    string cmd = "ffmpeg -y -f rawvideo -pixel_format bgr24 -video_size " +
                 to_string(finalWidth) + "x" + to_string(finalHeight) +
                 " -framerate " + to_string(fps) +
                 " -i pipe:0 -c:v libx264 -preset fast -crf 28 -b:v 500k -pix_fmt yuv420p \"" +
                 outFilename + "\"";
    FILE *ffmpeg_pipe = popen(cmd.c_str(), "w");
    if (!ffmpeg_pipe)
    {
        cerr << "Error al iniciar FFmpeg." << endl;
        return;
    }

    for (size_t f = 0; f < pressures_left.size(); f++)
    {
        Mat leftF = generate_heatmap_jet(coords_left, pressures_left[f],
                                         wFinal, hFinal, gridW, gridH,
                                         radius, smoothness);
        Mat rightF = generate_heatmap_jet(coords_right, pressures_right[f],
                                          wFinal, hFinal, gridW, gridH,
                                          radius, smoothness);
        draw_points_indices(leftF, coords_left);
        draw_points_indices(rightF, coords_right);

        Mat finalFrame(finalHeight, finalWidth, CV_8UC3, Scalar(255, 255, 255));
        putText(finalFrame, "Pressure", Point(480, 60), FONT_HERSHEY_SIMPLEX,
                0.5, Scalar(0, 0, 0), 1, LINE_AA);
        int leftX = margin;
        int rightX = leftX + wFinal + margin;
        int legendX = rightX + wFinal + margin;
        int topY = margin;

        leftF.copyTo(finalFrame(Rect(leftX, topY, wFinal, hFinal)));
        rightF.copyTo(finalFrame(Rect(rightX, topY, wFinal, hFinal)));
        legendContainer.copyTo(finalFrame(Rect(legendX - 22, topY + 19, legendWidth, barHeight)));

        fwrite(finalFrame.data, 1, finalFrame.total() * finalFrame.elemSize(), ffmpeg_pipe);
    }
    pclose(ffmpeg_pipe);
    cout << "Animaci贸n generada con JET: " << outFilename << endl;
}

// ------------------------------------------------------------
// C谩lculo del centro de presi贸n (COP)
// ------------------------------------------------------------
Point compute_center_of_pressure(
    const vector<int> &pressures,
    const vector<pair<double, double>> &coords)
{
    double sumP = 0, x = 0, y = 0;
    for (size_t i = 0; i < pressures.size(); i++)
    {
        sumP += pressures[i];
        x += coords[i].first * pressures[i];
        y += coords[i].second * pressures[i];
    }
    if (sumP <= 0)
        return Point(0, 0);
    return Point((int)(x / sumP), (int)(y / sumP));
}

// ------------------------------------------------------------
// Animaci贸n combinada de COP para ambas plantillas
// ------------------------------------------------------------
void generate_combined_COP_animation(
    const vector<Point> &cop_left,
    const vector<Point> &cop_right,
    int width, int height,
    double fps,
    int trail_length,
    const string &outFilename)
{
    int margin = 50;
    int finalWidth = (width * 2) + (margin * 3);
    int finalHeight = height + (margin * 2);

    string cmd = "ffmpeg -y -f rawvideo -pixel_format bgr24 -video_size " +
                 to_string(finalWidth) + "x" + to_string(finalHeight) +
                 " -framerate " + to_string(fps) +
                 " -i pipe:0 -c:v libx264 -preset fast -crf 28 -pix_fmt yuv420p \"" +
                 outFilename + "\"";
    FILE *pipe = popen(cmd.c_str(), "w");
    if (!pipe)
    {
        cerr << "Error al iniciar FFmpeg para COP." << endl;
        return;
    }

    deque<Point> trailL, trailR;
    for (size_t f = 0; f < cop_left.size() && f < cop_right.size(); ++f)
    {
        trailL.push_back(cop_left[f]);
        if (trailL.size() > (size_t)trail_length)
            trailL.pop_front();
        trailR.push_back(cop_right[f]);
        if (trailR.size() > (size_t)trail_length)
            trailR.pop_front();

        Mat frame(finalHeight, finalWidth, CV_8UC3, Scalar(255, 255, 255));
        // Dibujar rastro izquierda
        for (size_t i = 0; i < trailL.size(); ++i)
        {
            double alpha = double(i + 1) / trailL.size();
            int inten = int(255 * alpha);
            Scalar colL(0, 0, inten);
            Point pL = trailL[i] + Point(margin, margin);
            circle(frame, pL, 5, colL, -1, LINE_AA);
        }
        // Dibujar rastro derecha
        for (size_t i = 0; i < trailR.size(); ++i)
        {
            double alpha = double(i + 1) / trailR.size();
            int inten = int(255 * alpha);
            Scalar colR(inten, 0, 0);
            Point pR = trailR[i] + Point(width + margin * 2, margin);
            circle(frame, pR, 5, colR, -1, LINE_AA);
        }
        fwrite(frame.data, 1, frame.total() * frame.elemSize(), pipe);
    }
    pclose(pipe);
    cout << "COP combinado generado: " << outFilename << endl;
}

//------------------------------------------------------------
// Redis: conectar y leer stream
//------------------------------------------------------------
redisContext *connectToRedis(const string &host, int port, const string &password)
{
    redisContext *context = redisConnect(host.c_str(), port);
    if (!context || context->err)
    {
        cerr << "Error al conectar con Redis: " << (context ? context->errstr : "Desconocido") << endl;
        return nullptr;
    }
    if (!password.empty())
    {
        redisReply *reply = (redisReply *)redisCommand(context, "AUTH %s", password.c_str());
        if (!reply || reply->type == REDIS_REPLY_ERROR)
        {
            cerr << "Error en la autenticaci贸n Redis: " << (reply ? reply->str : "noreply") << endl;
            if (reply)
                freeReplyObject(reply);
            redisFree(context);
            return nullptr;
        }
        freeReplyObject(reply);
    }
    return context;
}

redisReply *readFromStream(redisContext *context, const string &lastID)
{
    return (redisReply *)redisCommand(context, "XREAD BLOCK 0 STREAMS %s %s",
                                      redisQueue.c_str(), lastID.c_str());
}

//------------------------------------------------------------
// Procesar mensaje
//------------------------------------------------------------
void processMessage(redisReply *msgData,
                    string &wearableId_L,
                    string &wearableId_R,
                    string &experimentId,
                    string &participantId,
                    string &sWId,
                    string &trialId)
{
    for (size_t k = 0; k < msgData->elements; k += 2)
    {
        redisReply *field = msgData->element[k];
        redisReply *value = msgData->element[k + 1];
        if (field->type == REDIS_REPLY_STRING && value->type == REDIS_REPLY_STRING)
        {
            string f = field->str;
            string v = value->str;
            if (f == "wearableId_L")
                wearableId_L = v;
            else if (f == "wearableId_R")
                wearableId_R = v;
            else if (f == "experimentId")
                experimentId = v;
            else if (f == "participantId")
                participantId = v;
            else if (f == "sWId")
                sWId = v;
            else if (f == "trialId")
                trialId = v;
        }
    }
}

//------------------------------------------------------------
// Cargar coordenadas JSON una vez
//------------------------------------------------------------
void readCoordinates(vector<pair<double, double>> &coords_left,
                     vector<pair<double, double>> &coords_right)
{
    read_coordinates("./in/leftPoints.json", coords_left);
    read_coordinates("./in/rightPoints.json", coords_right);
}

//------------------------------------------------------------
// Construir query params
//------------------------------------------------------------
string buildWearableIdsQuery(const string &wearableIdL, const string &wearableIdR)
{
    ostringstream oss;
    oss << "wearableIds=" << wearableIdL << "&wearableIds=" << wearableIdR;
    return oss.str();
}

//------------------------------------------------------------
// Fetch HTTP gen茅rico
//------------------------------------------------------------
string fetchUrlContent(const string &url)
{
    CURL *curl = curl_easy_init();
    string readBuffer;
    if (curl)
    {
        struct curl_slist *headers = NULL;
        string authHeader = "Authorization: Bearer " + getToken();
        headers = curl_slist_append(headers, authHeader.c_str());
        headers = curl_slist_append(headers, "Content-Type: application/json");
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
        CURLcode res = curl_easy_perform(curl);
        if (res != CURLE_OK)
        {
            cerr << "Error en la petici贸n HTTP: " << curl_easy_strerror(res) << endl;
        }
        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }
    return readBuffer;
}

//------------------------------------------------------------
// Extraer contenido interno del JSON API
//------------------------------------------------------------
string extractContent(const string &rawResponse)
{
    if (rawResponse.size() < 4 || rawResponse.substr(0, 2) != "[[" || rawResponse.substr(rawResponse.size() - 2) != "]]")
    {
        cerr << "Formato de respuesta inesperado." << endl;
        return "";
    }
    return rawResponse.substr(2, rawResponse.size() - 4);
}

//------------------------------------------------------------
// Separar CSVs izquierda/derecha
//------------------------------------------------------------
pair<string, string> splitCSVContent(const string &content)
{
    size_t pos = content.find("],[");
    if (pos == string::npos)
        pos = content.find("],");
    string first, second;
    if (pos != string::npos)
    {
        if (content.substr(pos, 3) == "],[")
        {
            first = content.substr(0, pos);
            second = content.substr(pos + 3);
        }
        else
        {
            first = content.substr(0, pos);
            second = content.substr(pos + 2);
        }
    }
    return {first, second};
}

//------------------------------------------------------------
// Convertir parte de JSON a CSV string
//------------------------------------------------------------
string processPart(const string &part)
{
    string result;
    size_t pos = 0;
    bool firstRow = true;
    while (pos < part.size())
    {
        size_t startQuote = part.find('"', pos);
        if (startQuote == string::npos)
            break;
        size_t endQuote = part.find('"', startQuote + 1);
        if (endQuote == string::npos)
            break;
        string row = part.substr(startQuote + 1, endQuote - startQuote - 1);
        if (!firstRow)
            result += "\n";
        result += row;
        firstRow = false;
        pos = endQuote + 1;
        while (pos < part.size() && (part[pos] == ',' || isspace(part[pos])))
            pos++;
    }
    return result;
}

//------------------------------------------------------------
// Parse CSV string a vector<vector<int>>
//------------------------------------------------------------
vector<vector<int>> parseCSV(const string &csvData)
{
    vector<vector<int>> data;
    stringstream ss(csvData);
    string line;
    while (getline(ss, line))
    {
        vector<int> row;
        stringstream ls(line);
        string val;
        while (getline(ls, val, ','))
        {
            try
            {
                row.push_back(stoi(val));
            }
            catch (...)
            {
                row.push_back(0);
            }
        }
        data.push_back(row);
    }
    return data;
}

//------------------------------------------------------------
// Fetch CSVs y parse
//------------------------------------------------------------
void fetchCSV(
    const string &baseUrl,
    const string &experimentId,
    const string &participantId,
    const string &sWId,
    const string &trialId,
    const string &wearableIdL,
    const string &wearableIdR,
    vector<vector<int>> &pressures_left,
    vector<vector<int>> &pressures_right)
{
    string wearableIdsQuery = buildWearableIdsQuery(wearableIdL, wearableIdR);
    string url = baseUrl + experimentId + "/" + participantId + "/" + sWId + "/" + trialId + "?" + wearableIdsQuery;
    string rawResponse = fetchUrlContent(url);
    string content = extractContent(rawResponse);
    auto parts = splitCSVContent(content);
    string leftCsv = processPart(parts.first);
    string rightCsv = processPart(parts.second);
    pressures_left = parseCSV(leftCsv);
    pressures_right = parseCSV(rightCsv);
}

//------------------------------------------------------------
// PostgreSQL: conectar e insertar ruta video
//------------------------------------------------------------
void createConnection()
{
    cnn = PQsetdbLogin(host, port, NULL, NULL, dataBase, user, passwd);
    if (!cnn || PQstatus(cnn) == CONNECTION_BAD)
    {
        cerr << "Error conexi贸n PostgreSQL: " << (cnn ? PQerrorMessage(cnn) : "desconocido") << endl;
        if (cnn)
            PQfinish(cnn);
        cnn = NULL;
    }
}

void updateTrial(const string &url, const string &trialId)
{
    if (!cnn)
        createConnection();
    if (!cnn)
        return;
    const char *updateQuery = "UPDATE trial SET \"heatMapVideoPath\"=$1 WHERE id=$2;";
    const char *paramValues[2] = {url.c_str(), trialId.c_str()};
    result = PQexecParams(cnn, updateQuery, 2, NULL, paramValues, NULL, NULL, 0);
    if (!result || PQresultStatus(result) != PGRES_COMMAND_OK)
    {
        cerr << "Error al actualizar trial: " << PQerrorMessage(cnn) << endl;
    }
    if (result)
        PQclear(result);
    PQfinish(cnn);
    cnn = NULL;
}

//------------------------------------------------------------
// Delete de la cola Redis
//------------------------------------------------------------
void deleteFromQueue(redisContext *context, const string &lastID)
{
    redisReply *delReply = (redisReply *)redisCommand(
        context,
        "XDEL %s %s",
        redisQueue.c_str(),
        lastID.c_str());
    if (delReply)
        freeReplyObject(delReply);
}

// Definir MKDIR por si la carpeta de salida de video no existe
void createDirectoryIfNotExists(const string &path)
{
    struct stat info;

    if (stat(path.c_str(), &info) == 0) // Si la ruta existe
    {
        if (info.st_mode & S_IFDIR)
        {
            cout << "La carpeta ya existe: " << path << endl;
        }
        else
        {
            cerr << "Existe un archivo con el mismo nombre: " << path << endl;
        }
        return;
    }

    // Si no existe, intentamos crearla
    if (MKDIR(path.c_str()) == 0)
    {
        cout << "Carpeta creada: " << path << endl;
    }
    else
    {
        cerr << "Error al crear la carpeta: " << path << endl;
    }
}
//------------------------------------------------------------
// Integraci贸n: fetchCSV + heatmap + COP
//------------------------------------------------------------
void fetchCSVAndGenerateAnimation(
    const vector<pair<double, double>> &coords_left,
    const vector<pair<double, double>> &coords_right,
    const string &wearableId_L,
    const string &wearableId_R,
    const string &experimentId,
    const string &participantId,
    const string &sWId,
    const string &trialId)
{
    createDirectoryIfNotExists("/app/backend/videos/hm_videos");
    string basePath = string("/app/backend/videos/hm_videos/experimentId_") + experimentId +
                      string("_participantId_") + participantId +
                      string("_trialId_") + trialId +
                      string("_sWId_") + sWId +
                      string("_wearableL_") + wearableId_L +
                      string("_wearableR_") + wearableId_R;
    string videoPath = basePath + "_V2.mp4";

    vector<vector<int>> pressures_left, pressures_right;
    fetchCSV(baseUrl, experimentId, participantId, sWId, trialId,
             wearableId_L, wearableId_R,
             pressures_left, pressures_right);

    generate_combined_animation_JET(pressures_left, pressures_right,
                                    coords_left, coords_right,
                                    videoPath);
    updateTrial(videoPath, trialId);

    // COP
    vector<Point> copL, copR;
    for (size_t i = 0; i < pressures_left.size(); ++i)
    {
        copL.push_back(compute_center_of_pressure(pressures_left[i], coords_left));
        copR.push_back(compute_center_of_pressure(pressures_right[i], coords_right));
    }
    string copVideo = basePath + "_COP.mp4";
    generate_combined_COP_animation(copL, copR,
                                    wFinal, hFinal, fps,
                                    50, copVideo);
    // opcional: updateTrial(copVideo, trialId);
}

//------------------------------------------------------------
// Procesar stream completo de Redis
//------------------------------------------------------------
void processStream(redisReply *stream, redisContext *context, string &lastID,
                   const vector<pair<double, double>> &coords_left,
                   const vector<pair<double, double>> &coords_right)
{
    if (!stream || stream->type != REDIS_REPLY_ARRAY || stream->elements < 2)
        return;
    redisReply *streamName = stream->element[0];
    redisReply *messages = stream->element[1];
    for (size_t j = 0; j < messages->elements; ++j)
    {
        redisReply *message = messages->element[j];
        if (message && message->type == REDIS_REPLY_ARRAY && message->elements >= 2)
        {
            redisReply *msgID = message->element[0];
            redisReply *msgData = message->element[1];
            if (msgID->type == REDIS_REPLY_STRING)
            {
                lastID = msgID->str;
                string wearableIdL, wearableIdR, experimentId, participantId, sWId, trialId;
                processMessage(msgData, wearableIdL, wearableIdR,
                               experimentId, participantId, sWId, trialId);
                fetchCSVAndGenerateAnimation(coords_left, coords_right,
                                             wearableIdL, wearableIdR,
                                             experimentId, participantId,
                                             sWId, trialId);
                deleteFromQueue(context, lastID);
            }
        }
    }
}

//------------------------------------------------------------
// Consumidor principal
//------------------------------------------------------------
void consumeFromQueue(const string &redisQueue)
{
    vector<pair<double, double>> coords_left, coords_right;
    readCoordinates(coords_left, coords_right);
    redisContext *context = connectToRedis("redis_container", 6379, "mi_contrase帽a_secreta");
    if (!context)
        return;
    string lastID = "0";
    while (true)
    {
        if (context->err)
            break;
        cout << " Buscando mensajes en la cola..." << endl;
        redisReply *reply = readFromStream(context, lastID);
        if (reply && reply->type == REDIS_REPLY_ARRAY && reply->elements > 0)
        {
            for (size_t i = 0; i < reply->elements; ++i)
            {
                processStream(reply->element[i], context, lastID,
                              coords_left, coords_right);
            }
        }
        if (reply)
            freeReplyObject(reply);
    }
    redisFree(context);
}

//------------------------------------------------------------
// MAIN
//------------------------------------------------------------
int main()
{
    cout << " Iniciando el proceso de generaci贸n de animaciones V2..." << endl;
    consumeFromQueue(redisQueue);
    return 0;
}
